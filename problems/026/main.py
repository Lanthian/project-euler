""" Reciprocal Cycles

A unit fractions contains 1  in the numerator. The decimal representation of the
  unit fractions with denominators 2 to 10 are given:
    1/2 = 0.5
    1/3 = 0.(3)
    1/4 = 0.25
    1/5 = 0.2
    1/6 = 0.1(6)
    1/7 = 0.(142857)
    1/8 = 0.125
    1/9 = 0.(1)
    1/10 = 0.1
Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be 
  seen that 1/7 has a 6-digit recurring cycle.
Find the value of d < 1000 for which 1/d contains the longest recurring cycle in
  its decimal fraction part.
https://projecteuler.net/problem=26
"""

__author__ = "Liam Anthian"

# --- Imports ---
from re import sub
from common.primes import ordered_factors, prime_factors

# --- Conditions of the problem ---
DIVIDEND = 1
LIMIT = 1000            # Exclusive


def long_div(dividend: float, divisor: float, decimals: int) -> str:
    """Calculates the division of number `dividend` by number `divisor` up to 
    decimal place `decimals`. Return this result as a string."""
    out = ""
    str_div = str(dividend)
    
    carry = 0
    decimal_flag = False

    while (len(str_div) != 0):
        # Check for segue to decimals
        if str_div[0] == ".": 
            out += str_div[0]
            decimal_flag = True
        
        else:
            # Count the number of decimal places calculated so far
            if decimal_flag:
                # Stop calculation if enough presented
                if decimals == 0: break
                decimals -= 1

            # Calculate division at current place
            cur_div = carry + int(str_div[0])
            out += str(cur_div // divisor)
            carry = 10 * (cur_div % divisor)
        
        # Step forward
        str_div = str_div[1:]
        if len(str_div) == 0 and decimals > 0:
            # Append decimal point if missing and extend dividend by a zero
            if decimal_flag == False: str_div += "."
            str_div += "0"

    # Return result, dropping leading and trailing 0s
    trimmed = out.strip("0")
    if trimmed[0] == ".": trimmed = "0" + trimmed   # reattach 0 before .
    if trimmed[-1] == ".": trimmed = trimmed[:-1]   # drop pointless .
    return trimmed

# def sub_reps(seq: str) -> list[str]:
#     """Finds and returns a sorted list of all repeat sub-patterns in a string 
#     sequence `seq`."""
#     subs = set()
#     for i in range(len(seq)):
#         for j in range(i+1, len(seq)+1):
#             if seq[i:j] in seq[j:]: subs.add(seq[i:j])
#    
#     out = list(subs)
#     out.sort()
#     return out

# def sub_suc_reps(seq: str) -> list[str]:
#     """Finds and returns a sorted list of all complete (max length) repeated, 
#     successive sub-patterns within string `sequence`."""
#     subs = set()
#
#     # Across each possible subsequence of the sequence `seq`;
#     for i in range(len(seq)):
#         for j in range(i+1, ((i+len(seq))//2)+1):
#
#             # Check if successive subsequence is equal
#             if seq[i:j] == seq[j:2*j-i]:
#                 # And if no sub successive patterns within sequence, add to set
#                 if len(sub_suc_reps(seq[i:j])) == 0: subs.add(seq[i:j])
#                 """DISCOVERY: If unrelated subpatterns within, fails.
#                   e.g. "aabbaabb" -> "aabb" won't return as it has the repeated 
#                   sub pattern of "aa" (and also "bb").
#                 """
#  
#     out = list(subs)
#     out.sort()
#     return out

# def sub_cycle(seq: str) -> str:
#     """Finds and returns the first repeated, successive sub-pattern (cycle) 
#     within string `sequence`. If no cycled pattern found, returns empty string. 
#    
#     Note: pattern is only checked to repeat once, strings such as "aab" will 
#     wrongfully return "a" as a cycle.
#     Would be more accurately named 'sub_successive_rep()'"""
#     # Across each possible subsequence of the sequence `seq`;
#     for i in range(len(seq)):
#         for j in range(i+1, ((i+len(seq))//2)+1):
#
#             # Check if successive subsequence is equal
#             if seq[i:j] == seq[j:2*j-i]:
#                 # And if no repeats of cycle within sequence, add to set
#                 if len(sub_cycle(seq[i:j])) == 0: return seq[i:j]
#                 """DISCOVERY: If unrelated subpatterns within, fails.
#                   e.g. "aabbaabb" -> "aabb" won't return as it has the repeated 
#                   sub pattern of "aa" (and also "bb").
#                 """
#    
#     return ""

def repetend_length(dividend: int, divisor: int) -> str:
    """Finds the length of the repetend portion of a decimal generated by
    dividing `dividend` by `divisor`."""
    # integer.prefix(repetend)  e.g.    0.1(6)

    # Find factors of divisor-1 : if âˆƒ repetend, length = one of these factors
    facs = ordered_factors(divisor-1)
    
    # Find a loose upper bound for decimal prefix length
    temp = dividend
    offset = 0
    while(temp < divisor):
        offset += 1
        temp *= 10

    # Long divide to (2 * max repetend length + prefix bound) decimal places
    decimal = sub(r'\d+[.]', '', long_div(dividend, divisor, 2*facs[-1]+offset))
    # Crop prefix
    rep = decimal[offset:]

    # Try patterns of each factor length
    for f in facs:
        match = True

        # Check if pattern of length `f` adjacently repeats
        repetend = rep[:f]
        for slice in range(f, 2*facs[-1]-f+1, f):
            # If non-match, move on to next factor
            if repetend != rep[slice:slice+f]:
                match = False
                break
        
        # Repetend found if match still true! Return this length of cycle
        if match: return f

    # If no repetend found, return length as 0
    return 0


# --- Calculation ---
def main():
    max_cycle_divisor = None
    max_cycle_length = 0

    for i in range(LIMIT-1, 1, -1):
        # Max repetend length of i <= i-1; use this to break early
        if i-1 < max_cycle_length: break

        # Divisors with factors of just 2 or 5 have no repetend.
        if len(set(prime_factors(i)).difference({2,5})) == 0: continue

        # Find repetend length of each DIVISOR/i
        length = repetend_length(DIVIDEND, i)
        if length > max_cycle_length:
            # Update if new max length found
            max_cycle_length = length
            max_cycle_divisor = i


    # --- Output ---
    print(max_cycle_divisor) # 983
    return


# --- Research ---
"""
https://pballew.blogspot.com/2008/08/repeating-decimal-periods-and-patterns.html
  #:~:text=In%20looking%20at%201%2F17,%2C%208%2C%20or%2016%20digits.
https://mathlesstraveled.com/2019/01/29/finding-prefix-and-repetend-length/
"""
