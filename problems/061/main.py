""" Cyclical Figurate Numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are 
all figurate (polygonal) numbers and are generated by the following formulae:
    Triangle    P3,n = n(n+1)/2     1,3,6,10,15,...
    Square      P4,n = n^2          1,4,9,16,25,...
    Pentagonal  P5,n = n(3n-1)/2    1,5,12,22,35,...
    Hexagonal   P6,n = n(2n-1)/2    1,6,15,28,45,...
    Heptagonal  P7,n = n(5n-3)/2    1,7,18,34,55,...
    Octagonal   P8,n = n(3n-2)      1,8,21,40,65,...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three 
  interesting properties.
    1. The set is cyclic, in that the last two digits of each number is the 
      first two digits of the next number (including the last number with the 
      first).
    2. Each polygonal type: triangle (P3,127 = 8128), square (P4,91 = 8281), and
      pentagonal (P5,44 = 2882), is represented by a different number in the 
      set.
    3. This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which 
  each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and 
  octagonal, is represented by a different number in the set.
https://projecteuler.net/problem=61
"""

__author__ = "Liam Anthian"

# --- Imports ---
from common.nums import n_gonal_generator

# --- Conditions of the problem ---
DIGITS = 4
OVERLAP = 2
N_GONS = list(range(3,8+1))


def connect(a: str, b: str, overlap: int) -> bool:
    """Returns if the end of `a` equals the start of `b`, by and number of 
    `overlap` characters."""
    if a[-overlap:] == b[:overlap]: return True
    return False

def chain(seen: list[int], options: list[list[int]], overlap: int
          ) -> list[int] | None: 
    """Searches through a list of lists of numbers `options`, chaining them 
    together cyclically by an `overlap` length of characters, returning the 
    first valid chain if found. Otherwise, returns None. `seen` is a log of 
    current path in explored chain."""
    # Initial case
    if seen == [] :
        for v in options[0]:
            suffix = chain(seen + [v], options[1:], overlap)
            if suffix != None: return [v] + suffix
        
        # No cyclic chains - return None
        return None

    prev = str(seen[-1])
    # Basecase / end of search
    if options == []:
        # Insist end term cycle connects with first 
        if connect(prev, str(seen[0]), overlap): return []
        return None

    # For each set of options, try finding valid chain continuations
    for i,val_set in enumerate(options): 
        for v in val_set:
            # Avoid doubling up on characters
            if v in seen: continue

            # Recursively deepen chain
            elif connect(prev, str(v), overlap):
                suffix = chain(seen + [v], options[:i]+options[i+1:], overlap)
                if suffix != None: return [v] + suffix

    # If no valid chains found, return None
    return None


# --- Calculation ---
def main():
    # Prepare n_gons in DIGITS long range
    n_gon_dict = {}
    for n in N_GONS:
        in_range = []
        # Uses n_gonal_generator for each n, starting from 1.
        for v in n_gonal_generator(n):
            if v < 10**(DIGITS-1): continue
            elif v > 10**DIGITS-1: break
            in_range.append(v)
        # Store n_gon
        n_gon_dict[n] = in_range
    
    # Search for chain with n_gons
    path = chain([], [v for k,v in n_gon_dict.items()], OVERLAP)


    # --- Output ---
    if path != None: print(sum(path)) # 28,684
    return
